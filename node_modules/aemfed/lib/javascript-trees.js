"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const request_promise_native_1 = __importDefault(require("request-promise-native"));
const utils_1 = require("./utils");
class JavascriptTrees {
    constructor(config, clientlibTree) {
        this.libs = new Map();
        this.files = new Map();
        this.proxies = new Map();
        config = config || {
            name: "localhost:4502",
            server: "http://admin:admin@localhost:4502"
        };
        this.server = config.server;
        this.name = config.name;
        this.clientlibTree = clientlibTree;
    }
    addLibAndFiles(jsLib) {
        const sanitizedUrl = this.sanitizeJsLibUrl(jsLib);
        if (!sanitizedUrl) {
            return Promise.reject(`Could not sanitize '${jsLib}', so don't process`);
        }
        const sw = Date.now();
        let swInner = Date.now();
        return this.addLib(sanitizedUrl)
            .then(jsFileNames => {
            swInner = Date.now();
            return this.updateJsFileLengths(jsFileNames);
        })
            .then(updatedJsFileObjects => {
        })
            .catch(err => {
            console.error(`Error: ${err}`);
        });
    }
    getMappedFile(jsLibPath, lineNr) {
        return this.addLibAndFiles(jsLibPath).then(() => {
            const jsLibFilePaths = this.libs.get(jsLibPath);
            if (jsLibFilePaths) {
                let lineCounter = 0;
                for (const jsFilePath of jsLibFilePaths) {
                    const jsFile = this.files.get(jsFilePath);
                    if (jsFile) {
                        const end = lineCounter + jsFile.lines;
                        if (lineNr > lineCounter && lineNr <= end) {
                            return {
                                line: lineNr - lineCounter,
                                path: jsFile.path
                            };
                        }
                        else {
                            lineCounter = end;
                        }
                    }
                    else {
                        console.error(chalk_1.default `[{red ERROR}] File not found when mapping '${jsLibPath}': ${jsFilePath}`);
                    }
                }
            }
        });
    }
    resetFiles(filePaths) {
        if (filePaths) {
            filePaths.forEach(filePath => this.files.delete(utils_1.normalisePath(filePath)));
        }
        else {
            this.files.clear();
        }
    }
    resetLibs() {
        this.libs.clear();
    }
    addLib(sanitizedUrl) {
        let jsFileNames = this.libs.get(sanitizedUrl);
        if (jsFileNames) {
            return Promise.resolve(jsFileNames);
        }
        let sw = Date.now();
        const debugPostFix = (sanitizedUrl.indexOf("?") > -1 ? "&" : "?") + "debug=true";
        return request_promise_native_1.default(this.server + sanitizedUrl + debugPostFix).then((js) => {
            sw = Date.now();
            jsFileNames = this.processJsRegex(js);
            this.libs.set(sanitizedUrl, jsFileNames);
            return jsFileNames;
        });
    }
    updateJsFileLengths(jsFileJcrPaths, force = false) {
        const promises = jsFileJcrPaths.map(jsFileName => {
            return this.updateJsFileLength(jsFileName, force);
        });
        return Promise.all(promises).then(updatedJsFiles => {
            return updatedJsFiles.filter((file) => typeof file !== "undefined");
        });
    }
    updateJsFileLength(jsFileJcrPath, force = false) {
        if (force) {
            this.files.delete(jsFileJcrPath);
        }
        if (!this.files.has(jsFileJcrPath)) {
            const debugPostFix = (jsFileJcrPath.indexOf("?") > -1 ? "&" : "?") + "debug=true";
            return request_promise_native_1.default(this.server + jsFileJcrPath + debugPostFix)
                .then((js) => {
                const lines = js.split(/[\n\u0085\u2028\u2029]|\r\n?/);
                return lines.length;
            })
                .catch(err => {
                console.error(`Error when getting ${jsFileJcrPath}: ${err} (add file with 0 lines)`);
                return 0;
            })
                .then((lines) => {
                const jsFile = {
                    lines,
                    path: jsFileJcrPath
                };
                this.files.set(jsFileJcrPath, jsFile);
                return jsFile;
            });
        }
        else {
            return Promise.resolve();
        }
    }
    sanitizeJsLibUrl(jsLib) {
        const match = /^(\/.*?)(\.min)?(\.[0-9a-f]{32})?(\.js)(\?.*?)?$/.exec(jsLib);
        if (match) {
            const baseName = match[1];
            const extension = match[4];
            const target = this.clientlibTree.findProxyTarget(baseName);
            if (target) {
                return target + extension;
            }
            else {
                console.error("sanitizeJsLibUrl no target was found for", baseName);
            }
        }
    }
    processJsRegex(body) {
        const blockRegex = /Loader\.js *= *\[([\s\S]*?)\];/gim;
        const lineRegex = /"(.*?)"/gi;
        const jsFileJcrPaths = [];
        const blockMatches = this.getMatches(blockRegex, body);
        const blockMatch = blockMatches[0];
        if (blockMatch) {
            const blockContent = blockMatch[1];
            const jsFileMatches = this.getMatches(lineRegex, blockContent);
            jsFileMatches.forEach(jsFileMatch => {
                jsFileJcrPaths.push(jsFileMatch[1]);
            });
        }
        return jsFileJcrPaths;
    }
    getMatches(regex, str) {
        let m;
        const result = [];
        while ((m = regex.exec(str)) !== null) {
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            result.push(m);
        }
        return result;
    }
}
exports.JavascriptTrees = JavascriptTrees;
