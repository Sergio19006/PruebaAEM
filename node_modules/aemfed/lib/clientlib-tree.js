"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const request_promise_native_1 = __importDefault(require("request-promise-native"));
const javascript_trees_1 = require("./javascript-trees");
const utils_1 = require("./utils");
class ClientlibTree {
    constructor(config) {
        config = config || {
            name: "localhost:4502",
            server: "http://admin:admin@localhost:4502"
        };
        this.name = config.name;
        this.server = config.server;
        this.dumpLibsPath =
            config.dumpLibsPath || "/libs/granite/ui/content/dumplibs.html";
        this.libs = new Map();
        this.jsTrees = new javascript_trees_1.JavascriptTrees(config, this);
    }
    init() {
        const sw = Date.now();
        let swInner = Date.now();
        return request_promise_native_1.default(this.server + this.dumpLibsPath).then((html) => {
            console.log(chalk_1.default `[{blue ${this.name}}] Get data from server: ${(Date.now() - swInner).toString()} ms`);
            swInner = Date.now();
            this.libs = this.processHtmlRegex(html);
            console.log(chalk_1.default `[{blue ${this.name}}] Process data: ${(Date.now() - swInner).toString()} ms`);
            console.log(chalk_1.default `[{blue ${this.name}}] Clientlib tree: ${(Date.now() - sw).toString()} ms`);
        });
    }
    findClientlibs(filePathRelative) {
        let jcrPath = utils_1.normalisePath(filePathRelative);
        jcrPath = jcrPath.startsWith("/") ? jcrPath : "/" + jcrPath;
        const result = [];
        for (const [key, lib] of this.libs) {
            if (lib.name === jcrPath) {
                result.push(lib);
            }
            if (lib.embedded.indexOf(jcrPath) > -1) {
                result.push(lib);
            }
        }
        return result;
    }
    findProxyTarget(jcrPath) {
        const proxyPaths = ["/apps/", "/etc/", "/libs/"];
        const match = /^(\/etc\.clientlibs\/)(.*)/.exec(jcrPath);
        const paths = match
            ? proxyPaths.map(prefix => prefix + match[2])
            : [jcrPath];
        for (const libPath of paths) {
            const lib = this.libs.get(libPath);
            if (lib) {
                return libPath;
            }
        }
        return;
    }
    processHtmlRegex(body) {
        const tableRegex = /<table>([\s\S]*?)<\/table>/gim;
        const rowRegex = /<tr>([\s\S]*?)<\/tr>/gim;
        const libs = new Map();
        const tables = this.getMatches(tableRegex, body);
        const tableMatch = tables[0];
        if (tableMatch) {
            const tableContent = tableMatch[1];
            const rows = this.getMatches(rowRegex, tableContent);
            rows.forEach(rowM => {
                const lib = this.processRowRegex(rowM[1]);
                if (lib && lib.name) {
                    libs.set(lib.name, lib);
                }
            });
        }
        return libs;
    }
    processRowRegex(row) {
        const cellRegex = /<td>([\s\S]*?)<\/td>/gim;
        let cellIndex;
        (function (cellIndex) {
            cellIndex[cellIndex["name"] = 0] = "name";
            cellIndex[cellIndex["types"] = 1] = "types";
            cellIndex[cellIndex["categories"] = 2] = "categories";
            cellIndex[cellIndex["theme"] = 3] = "theme";
            cellIndex[cellIndex["channels"] = 4] = "channels";
            cellIndex[cellIndex["dependencies"] = 5] = "dependencies";
            cellIndex[cellIndex["embedded"] = 6] = "embedded";
        })(cellIndex || (cellIndex = {}));
        const cells = this.getMatches(cellRegex, row);
        const expectedCellsLength = cellIndex.embedded + 1;
        if (cells.length === expectedCellsLength) {
            const names = this.getLinkList(cells[cellIndex.name]);
            if (names.length) {
                const name = names[0].text;
                const lib = {
                    categories: [],
                    channels: [],
                    dependencies: [],
                    embedded: [],
                    name
                };
                const types = this.getLinkList(cells[cellIndex.types]);
                types.forEach(type => {
                    if (type.text === "JS") {
                        lib.js = type.href;
                    }
                    else if (type.text === "CSS") {
                        lib.css = type.href;
                    }
                    else {
                        console.log(this.name + ": UNKNOWN TYPE: " + type.text);
                    }
                });
                lib.categories = this.getLinkList(cells[cellIndex.categories]).map(link => link.text);
                const themeM = cells[cellIndex.theme];
                if (themeM) {
                    lib.theme = themeM[1];
                }
                lib.channels = this.getLinkList(cells[cellIndex.channels]).map(link => link.text);
                lib.dependencies = this.getLinkList(cells[cellIndex.dependencies]).map(link => link.text);
                lib.embedded = this.getLinkList(cells[cellIndex.embedded]).map(link => link.text);
                return lib;
            }
            else {
                console.log(this.name + ": Row w/o a name: " + row);
            }
        }
        else {
        }
    }
    getLinkList(match) {
        const index = {
            all: 0,
            href: 1,
            text: 2
        };
        const result = [];
        const links = this.getLinksRegex(match[1]);
        links.forEach(linkM => {
            result.push({
                href: linkM[index.href],
                text: linkM[index.text]
            });
        });
        return result;
    }
    getLinksRegex(cellContent) {
        const anchorRegex = /<a ?[\s\S]*?href=["'](.*?)["'][\s\S]*?>([\s\S]*?)<\/a>/gim;
        return this.getMatches(anchorRegex, cellContent);
    }
    getMatches(regex, str) {
        let m;
        const result = [];
        while ((m = regex.exec(str)) !== null) {
            if (m.index === regex.lastIndex) {
                regex.lastIndex++;
            }
            result.push(m);
        }
        return result;
    }
}
exports.ClientlibTree = ClientlibTree;
