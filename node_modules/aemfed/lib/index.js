"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const aemsync_1 = require("aemsync");
const chalk_1 = __importDefault(require("chalk"));
const decode_html_1 = __importDefault(require("decode-html"));
const graceful_fs_1 = __importDefault(require("graceful-fs"));
const minimist_1 = __importDefault(require("minimist"));
const opn_1 = __importDefault(require("opn"));
const path_1 = __importDefault(require("path"));
const package_json_1 = __importDefault(require("./../package.json"));
const bsWrapper = __importStar(require("./bs-wrapper"));
const messages = __importStar(require("./messages"));
const UpdateCheck = __importStar(require("./update-check"));
const bsQrCodePlugin = require("./bs-qr-code");
function separate() {
    console.log("---------------------------------------");
}
const MSG_HELP = `Usage: aemfed [OPTIONS]
Options:
  -t targets           Default is http://admin:admin@localhost:4502
  -p proxy_port        Default is 3000
  -w path_to_watch     Default is current
  -e exclude_filter    Anymatch exclude filter; disabled by default
  -i sync_interval     Update interval in milliseconds; default is 100
  -o open_page         Browser page to be opened after successful launch; default is "false".
  -b browser           Browser where page should be opened in; this parameter is platform dependent; for example, Chrome is "google chrome" on OS X, "google-chrome" on Linux and "chrome" on Windows; default is "google chrome"
  -q load_qr           Enable QR code plugin for connected browsers; default is "true".
  -h                   Displays this screen
  -v                   Displays version of this package`;
const workingDirs = [];
function reloadBrowser(error, host, inputList, packItems) {
    if (!error) {
        bsWrapper.reload(host, inputList);
    }
    else {
        console.error(chalk_1.default `[{blue ${host}}] [{red Error}] when pushing pack: ${decode_html_1.default(error)}`);
        const ref = messages.getRef(error, /systemId: file:\/\/.*?\/jcr_root(\/.*?); lineNumber: (\d+); columnNumber: (\d+);/, workingDirs);
        const logLine = messages.formatMessage(ref);
        if (logLine) {
            console.log(logLine);
        }
    }
}
function init() {
    "use strict";
    const args = minimist_1.default(process.argv.slice(2));
    if (args.h) {
        console.log(MSG_HELP);
        return;
    }
    if (args.v) {
        console.log(package_json_1.default.version);
        return;
    }
    workingDirs.splice(0, workingDirs.length);
    const dirs = args.w ? args.w : ".";
    dirs.split(",").forEach((dir) => {
        const absDir = path_1.default.resolve(dir);
        if (!graceful_fs_1.default.existsSync(absDir)) {
            console.log("Invalid path, so skipping:", chalk_1.default.yellow(absDir));
        }
        else {
            workingDirs.push(absDir);
        }
    });
    if (workingDirs.length === 0) {
        console.log("No valid paths found in: ", chalk_1.default.yellow(args.w));
        return;
    }
    const targets = args.t || "http://admin:admin@localhost:4502";
    const proxyPort = parseInt(args.p, 10) || 3000;
    const pushInterval = parseInt(args.i, 10) || 100;
    const exclude = args.e || "";
    const startPage = args.o || "false";
    const startBrowser = args.b || "google chrome";
    const bsPlugins = [];
    if (args.q !== "false") {
        bsPlugins.push({
            module: bsQrCodePlugin,
            options: {
                onload: false
            }
        });
    }
    separate();
    console.log("Working dirs:", workingDirs);
    console.log("Targets:", targets);
    console.log("Proxy port:", proxyPort);
    console.log("Interval:", pushInterval);
    console.log("Exclude:", exclude);
    separate();
    console.log(chalk_1.default `Something missing or not working as expected, open an issue on GitHub: {yellow https://github.com/abmaonline/aemfed/issues}`);
    separate();
    UpdateCheck.check(package_json_1.default)
        .then(update => {
        const message = messages.formatUpdateMessage(update);
        if (message) {
            console.log(message);
        }
    })
        .catch(err => {
        console.error(`Failed to check for updates: ${err}`);
    });
    const targetList = targets.split(",");
    const styleLinkPattern = '(<link rel="stylesheet" href="/[^">]*?)(.min)?(.[0-9a-f]{32})?(.css)("[^>]*>)';
    const jsScriptPattern = '(<script type=".*?/javascript" src="/[^">]*?(.min)?(.[0-9a-f]{32})?)(.js)("[^>]*>)';
    function rewriteClientlibIncludes(matchedLinkElement, pattern) {
        const regex = new RegExp(pattern, "i");
        const match = regex.exec(matchedLinkElement);
        if (match) {
            return match[1] + match[4] + "?browsersync=" + Date.now() + match[5];
        }
        else {
            console.warn("Could not rematch " +
                matchedLinkElement +
                " to rewrite url w/o .min and .hash");
            return matchedLinkElement;
        }
    }
    bsWrapper.create({
        bsOptions: {
            plugins: bsPlugins,
            rewriteRules: [
                {
                    fn: (req, res, matchedLinkElement) => {
                        return rewriteClientlibIncludes(matchedLinkElement, styleLinkPattern);
                    },
                    match: new RegExp(styleLinkPattern, "gi")
                },
                {
                    fn: (req, res, matchedLinkElement) => {
                        return rewriteClientlibIncludes(matchedLinkElement, jsScriptPattern);
                    },
                    match: new RegExp(jsScriptPattern, "gi")
                }
            ]
        },
        jcrContentRoots: workingDirs,
        proxyPort,
        servers: targetList
    });
    const pipelineArgs = {
        interval: 600,
        onPushEnd: reloadBrowser,
        targets: targetList
    };
    const pipeline = new aemsync_1.Pipeline(pipelineArgs);
    pipeline.start();
    const watcher = new aemsync_1.Watcher();
    const watcherArgs = {
        callback: localPath => {
            setTimeout(() => {
                pipeline.enqueue(localPath);
            }, pushInterval);
        },
        exclude,
        workingDirs
    };
    watcher.watch(watcherArgs);
    if (startPage !== "false") {
        opn_1.default(startPage, {
            app: startBrowser
        });
    }
    separate();
}
exports.init = init;
