"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const os_1 = require("os");
const path_1 = require("path");
const proxy_agent_1 = __importDefault(require("proxy-agent"));
const request_promise_native_1 = __importDefault(require("request-promise-native"));
const util_promisify_1 = __importDefault(require("util.promisify"));
const writeFile = util_promisify_1.default(fs_1.default.writeFile);
const mkdir = util_promisify_1.default(fs_1.default.mkdir);
const readFile = util_promisify_1.default(fs_1.default.readFile);
const compareVersions = (a, b) => a.localeCompare(b, "en-US", { numeric: true });
const getFile = (name, distTag) => __awaiter(this, void 0, void 0, function* () {
    const rootDir = os_1.tmpdir();
    const subDir = path_1.join(rootDir, "update-check");
    if (!fs_1.default.existsSync(subDir)) {
        yield mkdir(subDir);
    }
    const fileName = `${name}-${distTag}.json`;
    return path_1.join(subDir, fileName);
});
const evaluateCache = (file, time, interval) => __awaiter(this, void 0, void 0, function* () {
    if (fs_1.default.existsSync(file)) {
        const content = yield readFile(file, "utf8");
        const { lastUpdate, latest } = JSON.parse(content);
        const nextCheck = lastUpdate + interval;
        if (nextCheck > time) {
            return {
                latest,
                shouldCheck: false
            };
        }
    }
    return {
        latest: undefined,
        shouldCheck: true
    };
});
const updateCache = (file, latest, lastUpdate) => __awaiter(this, void 0, void 0, function* () {
    const fileContent = {
        lastUpdate,
        latest
    };
    const content = JSON.stringify(fileContent);
    yield writeFile(file, content);
});
const loadPackage = (url, packageInfo) => {
    const userAgent = `Mozilla/5.0 (${process.platform}; ${process.arch}) Node.js/${process.version.slice(1)} ${packageInfo.name}/${packageInfo.version}`;
    const proxyAddress = process.env.http_proxy ||
        process.env.HTTP_PROXY ||
        process.env.https_proxy ||
        process.env.HTTPS_PROXY;
    const proxyAgent = proxyAddress ? new proxy_agent_1.default(proxyAddress) : undefined;
    const options = {
        agent: proxyAgent,
        headers: {
            "User-Agent": userAgent
        },
        json: true,
        timeout: 2000
    };
    return request_promise_native_1.default(url, options);
};
const getMostRecent = (url, distTag, packageInfo) => __awaiter(this, void 0, void 0, function* () {
    const spec = yield loadPackage(url, packageInfo);
    const version = spec[distTag];
    if (!version) {
        throw new Error(`Distribution tag '${distTag}' is not available`);
    }
    return version;
});
const defaultConfig = {
    distTag: "latest",
    interval: 64800000,
    url: "https://aemfed.io/latest"
};
function check(packageInfo, config) {
    return __awaiter(this, void 0, void 0, function* () {
        if (typeof packageInfo !== "object") {
            throw new Error("The first parameter should be your package.json file content");
        }
        const { name, version } = packageInfo;
        const time = Date.now();
        const { distTag, interval, url } = Object.assign({}, defaultConfig, config);
        const file = yield getFile(name, distTag);
        let latest;
        let shouldCheck = true;
        ({ shouldCheck, latest } = yield evaluateCache(file, time, interval));
        if (shouldCheck) {
            latest = yield getMostRecent(url, distTag, packageInfo);
            yield updateCache(file, latest, time);
        }
        if (latest) {
            const comparision = compareVersions(packageInfo.version, latest);
            if (comparision === -1) {
                const updateResult = {
                    fromCache: !shouldCheck,
                    latest,
                    name,
                    version
                };
                return updateResult;
            }
        }
        return;
    });
}
exports.check = check;
